import ContinuedFractions, Arithmetic, RSAvulnerableKeyGenerator
import sys
sys.setrecursionlimit(1000000)

def hack_RSA(e,n):
    '''
    Finds d knowing (e,n)
    applying the Wiener continued fraction attack
    '''
    frac = ContinuedFractions.rational_to_contfrac(e, n)
    convergents = ContinuedFractions.convergents_from_contfrac(frac)
    
    for (k,d) in convergents:
        
        #check if d is actually the key
        if k!=0 and (e*d-1)%k == 0:
            phi = (e*d-1)//k
            s = n - phi + 1
            # check if the equation x^2 - s*x + n = 0
            # has integer roots
            discr = s*s - 4*n
            if(discr>=0):
                t = Arithmetic.is_perfect_square(discr)
                if t!=-1 and (s+t)%2==0:
                    print("Hacked!")
                    return d

# TEST functions

def modexp( g, u, p):
    s = 1
    while u !=0:
        if u & 1:
            s = (s * g)%p
        u >>=1
        g = (g * g)%p
    return s
    
    
if __name__ == "__main__":
    n = 109966163992903243770643456296093759130737510333736483352345488643432614201030629970207047930115652268531222079508230987041869779760776072105738457123387124961036111210544028669181361694095594938869077306417325203381820822917059651429857093388618818437282624857927551285811542685269229705594166370426152128895901914709902037365652575730201897361139518816164746228733410283595236405985958414491372301878718635708605256444921222945267625853091126691358833453283744166617463257821375566155675868452032401961727814314481343467702299949407935602389342183536222842556906657001984320973035314726867840698884052182976760066141
    e = 30749686305802061816334591167284030734478031427751495527922388099381921172620569310945418007467306454160014597828390709770861577479329793948103408489494025272834473555854835044153374978554414416305012267643957838998648651100705446875979573675767605387333733876537528353237076626094553367977134079292593746416875606876735717905892280664538346000950343671655257046364067221469807138232820446015769882472160551840052921930357988334306659120253114790638496480092361951536576427295789429197483597859657977832368912534761100269065509351345050758943674651053419982561094432258103614830448382949765459939698951824447818497599
    c = 60627434129028814567404969251697807879433775099089276036015410639261901886263220690479587955645647729237126627894599166136756811335873604339498869129719440656776867314172756225023754233476201217843405147707204606506489409981939998604644568471901388086489470619171927867919622384085722093956759241836499067639379179411120052281316958208007504576202137300342827418254852620085360302233358835951034932808393567658291851385064158525774666702382955852511233053362902277921857534414199997716231020668999139795251740005513044276574836799364555665560793535452231662835543599932725511766192196706414172508995359134072584232582
    #test_is_perfect_square()
    #print("-------------------------")
    #test_hack_RSA()
    d = hack_RSA(e,n)
    print hex(modexp(c,d,n))